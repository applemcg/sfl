debug () 
{ 
    : it’s a dummy;
    return
}
debug_init () 
{ 
    : default debugging and pausing are OFF;
    : optinons ON, OFF, COMMENT;
    : date: 2023-03-05;
    : date: 2024-05-28;
    debug_off;
    pause_off
}
debug_list () 
{ 
    : Crunched debug_list;
    ${@:-echo} debug \
               debug_{init,list,save,off,on} foreach \
               function_{names,truth} isfunction myname pause \
               pause_{off,on} ssf
}
debug_save () 
{ 
    : save, collect the Debug List into the library;
    local lib=./debug.lib;
    debug_list fbdy | tee $lib;
    functions $lib 1>&2;
    comment if you can, back-up $lib
}
debug_off () 
{ 
    : no diagnostics, just return;
    : date: 2023-03-29;
    function debug () 
    { 
        : it’s a dummy;
        return
    }
}
debug_on () 
{ 
    : write a COMMENT, on STDERR, at a point in a function, listing ...;
    : the CALLER and any passed ARGS, who CALLED it, 3rd, and that CALLER, 4th as well;
    : lesson: NO user functions in DEBUG:;
    : date: 2022-03-07;
    : date: 2023-01-30;
    eval "debug () { printf \"%-21s\\t%-21s\\t%-21s : %s\\n\" \${FUNCNAME[3]} \${FUNCNAME[2]} \${FUNCNAME[1]} \"\$*\" 1>&2; }"
}
foreach () 
{ 
    : TCL legacy, FOREACH function Arg ...;
    : date: 2023-07-22;
    : date: 2024-04-29;
    debug ENTRY $# $1;
    [[ $# -lt 2 ]] && return;
    local cmd="$1";
    local arg;
    shift;
    debug SET $# $@;
    pause;
    for arg in $@;
    do
        : debug RUN $cmd "$arg";
        $cmd "$arg";
    done
}
function_names () 
{ 
    : File Functions, File name = function name;
    : use F!FILE to split multi-function files into unique files;
    : date: 2024-01-26;
    : date: 2024-04-30;
    : date: 2024-09-02;
    foreach function_truth ${*:-*} | awk '$2 ~ /^IS$/ { print $1 }'
}
function_truth () 
{ 
    : return Function IS OR NOT;
    : date: 2024-01-25;
    set ${1:-$(myname)};
    ssf $1 $(isfunction $1 && echo IS || echo NOT)
}
isfunction () 
{ 
    : prefer TYPE to Declare -f;
    : date: 2023-08-21;
    type -a $1 2> /dev/null | grep 'is a function' > /dev/null
}
myname () 
{ 
    : a calling functions NAME, default MYcaller;
    : 2 is the callers caller, 3 is theirs, etc...;
    : date: 2023-07-22;
    echo ${FUNCNAME[${1:-1}]}
}
pause () 
{ 
    : it’s a dummy;
    return
}
pause_off () 
{ 
    : do not pause, just return;
    : date: 2023-03-29;
    function pause () 
    { 
        : it’s a dummy;
        return
    }
}
pause_on () 
{ 
    : pause the script, waiting for the users CR;
    : date: 2023-01-30;
    eval "pause () { read -p \"[return] / [Ctrl-C] \${FUNCNAME[1]} \$@ ? \" < /dev/tty; }"
}
ssf () 
{ 
    : tab separated Arguments, String String Format;
    : date: 2023-08-02;
    : date: 2024-04-29;
    : date: 2024-06-28;
    local name=$1;
    shift;
    local valu="$*";
    debug ENTRY $# "$name" "$valu";
    printf "%s\t%s\n" "$name" "$valu"
}
